#include "stdafx.h"
#include "CreatureFactory.h"


CreatureFactory::CreatureFactory(void)
{
}


CreatureFactory::~CreatureFactory(void)
{
}

/**
 * Constructs a new Creature based on a given CreatureGenome.
 *
 * A CreatureGenome is represented as a directed graph which may contain cycles. It may also
 * contain self edges and multiple edges from a given node to another node.
 *
 * A Creature is represented as a directed acyclic graph where each node has only a single edge
 * coming into it. The DAG is generated by taking each cycle and expanding it into a new instance
 * of the graph as a subtree of the node. A parameter of each node is how many times it may be
 * expanded.
 *
 * Example Genome: Node 0 has an edge to Node 1, Node 1 has two edges to Node 2, Node 2 has an edge
 * to Node 3, and Node 3 creates a cycle with an edge back to Node 1. Assume that Node 1 may be
 * expanded only once.
 *
 * [0]->[1]=>[2]->[3]
 *       ^_________|
 *
 * Resulting Creature:
 *       [0]        
 *        |
 *       [1]
 *      /   \
 *    [2]   [2]
 *     |     |
 *    [3]   [3]
 *     |     |
 *    [1]   [0]      
 *   / \     / \
 * [2] [2]  [2] [2]
 *  |   |    |   |
 * [3] [3]  [3] [3]
 */
Creature * CreatureFactory::createCreatureFromGenome(CreatureGenome *genome, float x, float y, float z) {
   std::vector<BodySegment *> bodySegments;
   //keep track of how many expansions have been done
   int expansionLevel = 0;
   //create a list of segments to be expanded on subsequent iterations
   std::vector<BodySegment *> *currentExpansionList = new std::vector<BodySegment *>();
   //create a stack to represent the path to the current segment
   std::vector<BodySegmentGene *> visitedGeneStack;

   BodySegmentGene *rootGene = genome->getBodyGenes()[0];
   BodySegment *rootSegment = new BodySegment(rootGene);
   rootSegment->setPosition(btVector3(x, y, z));
   bodySegments.push_back(rootSegment);
   currentExpansionList->push_back(rootSegment);

   while(!currentExpansionList->empty()) {
      //create a new expansion list for the next iteration
      std::vector<BodySegment *> *nextExpansionList = new std::vector<BodySegment *>();
      for(BodySegment *currentSegment : *currentExpansionList) 
      {
         BodySegmentGene *currentGene = currentSegment->getGene();
         if(expansionLevel <= currentGene->getExpansionLimit())
         {
            buildHelper(genome, currentGene, currentSegment, nextExpansionList, visitedGeneStack, bodySegments);
         }
      }
      delete currentExpansionList;
      currentExpansionList = nextExpansionList;
      expansionLevel++;
   }
   return new Creature(genome, bodySegments);
}

void CreatureFactory::buildHelper(CreatureGenome *genome,
                 BodySegmentGene *parentGene,
                 BodySegment *parentSegment,
                 std::vector<BodySegment *> *expansionList,
                 std::vector<BodySegmentGene *> &visitedGeneStack,
                 std::vector<BodySegment *> &createdSegments) {
  
   visitedGeneStack.push_back(parentGene);

   const std::vector<BodySegmentGene *> &bodySegmentGenes = genome->getBodyGenes();
   JointInfo jointInfo;
   //iterate over each joint from the parent gene to its children
   for(JointGene *jointGene : genome->getJointGenesForBodySegmentGene(parentGene))
   {
      //look up the child gene using the joint's childId as an index
      BodySegmentGene *childGene = bodySegmentGenes[jointGene->getChildId()];
      BodySegment *childSegment = new BodySegment(childGene);
      createdSegments.push_back(childSegment);
      //construct the joint
      jointInfo.positionOnA = jointGene->getParentXYZ();
      jointInfo.positionOnB = jointGene->getChildXYZ();
      jointInfo.lowerLimits = jointGene->getLowerLimit();
      jointInfo.upperLimits = jointGene->getUpperLimit();
      childSegment->joinTo(*parentSegment, jointInfo);
    
      if(std::find(visitedGeneStack.begin(), visitedGeneStack.end(), childGene) != visitedGeneStack.end()) {
         //if the child gene already exists on the stack, a loop has been detected
         expansionList->push_back(childSegment);
      } else {
         //if the child gene hasn't been visited before, continue building its subtree
         buildHelper(genome, childGene, childSegment, expansionList, visitedGeneStack, createdSegments);
      }
   }
   visitedGeneStack.pop_back();
}